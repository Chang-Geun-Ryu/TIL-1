## switch문

|                   if/else문이 더 좋은 경우                   |               switch문이 더 좋은 경우               |
| :----------------------------------------------------------: | :-------------------------------------------------: |
| 수학성적이 100점 일 때 <br />수학 성적이 90점 이상 100점 미만일 때<br />수학 성적이 80점 이상 90점 미만일 때 | 성적이 A일 때<br />성적이 B일 때<br />성적이 C일 때 |
|                        \> >= < <= !=                         |                         ==                          |

매치 표현식의 결과 값에 따라 실행 할 구문을 선택



~~~c#
int menu = 2;

switch(menu)
{
	case 1:
	Console.WriteLine("You selected a cheese burger");
	break;
  case 2:  // break를 안써서 case3와 묶음
	case 3:  
	Console.WriteLine("You selected a double cheese burger");
	break;
	default: // 매치 표현식의 반환값이 일치하는 case구문이 없을 경우 실행
	Console.WriteLine("Plz enter a correct number");
		break;
}
~~~

`break`는 switch문을 빠져나갈 때 사용

모든 case 구문 다음에는 break구문을 넣어야함(없으면 컴파일 오류) / `fallthrough` 때문



Case에서 사용할 수 있는 상수형

- int[기본]
- long
- char (char 역시 정수형 int가 된다는건 char도 가능하다는 이야기)
- bool
- string(C#전용)
- 부동소수형들은 사용 불가









## 배열(Array)

- 동일한 자료형을 여럿 담을 수 있는 자료구조
- 베열 안에 있는 각 데이터를 요소(element)라고 부름
- 몇 개의 데이터를 담을지 결정한 뒤에는 그 수를 바꿀 수 없음
  - 단 내용 변경은 가능

#### 배열 선언하기

~~~c#
int[] ages = new int[3];
float[] height = new float[3];
~~~

`<자료형>[] <변수명> = new <자료형>[<개수>];`

<개수>개의 <자료형> 자료(data)를 담을 배열([])을 만든다 고만 이해



#### 배열 선언과 동시에 대입하기

기본형

~~~
int[] ages = new int[] {30, 14, 27};
<자료형>[] <변수명> = new <자료형>[]{<데이터(콤마로 구분)>}
~~~



단축형

~~~
int[] ages = {30, 14, 27};
<자료형>[] <변수명> = {<데이터(콤마로 구분)>}
~~~



#### 요소에 접근하기

- []안에 접근(access)하고자 하는 데이터의 색인(index)을 넣음
- []을 첨자(subscript)연산자라고 함
- 데이터가 들어가 있는 순서: 제일 앞(왼쪽 끝)에서부터 센다
- 접근한 뒤에는 그 요소를 변수와 똑같이 사용 가능



#### 배열의 색인

- 대부분 프로그래밍 언어에서 배열의 색인은 0부터 시작
  - 첫번째 = 0
  - 첫번째 = 1
- 이유? 메모리 때문

![스크린샷 2020-12-15 오후 11 21 16](https://user-images.githubusercontent.com/47776915/102226761-219d4d00-3f2c-11eb-9498-1e3ac07cdc2b.png)

- 한 배열 안에 있는 모든 요소는 연속된 메모리 공간에 위치한다



#### 배열선언 vs 요소접근

|         배열선언         |                요소접근                 |
| :----------------------: | :-------------------------------------: |
| Int[] ages = new int[3]; | ages[0] = int.Parse(Console.ReadLine()) |



#### Char 배열로 이름 출력하기

~~~c#
char[] myName = new char [5];
myName[0] = `D`;
myName[1] = `a`;
myName[2] = `i`;
myName[3] = `s`;
myName[4] = `y`;
Console.WriteLine($"My name is {myName[0]}{myName[1]}{myName[2]}{myName[3]}{myName[4]}")
~~~

- char배열과 문자열은 기본적으로 같은 데이터 방식

- 그래서 일부 언어에서는 문자열을 지원 안함(char 배열을 이용하면 되니까)

- 문자열은 그저 char배열보다 좀 더 많은 기능을 가지고 있고 배열의 문제점(길이가 변할 수 없음)을 해결

- ##### char배열은 반복문과 함께 프로그래머 면접문제로 매우 자주 나옴





## 반복문 

- 총 세 개의 반복문이 있음
  1. for문
  2. while문
  3. do...while문
- 세 개 모두 호환이 됨
- 하지만 각각의 반복문을 배우고 나면 언제 어떤 반복문을 쓸지 합리적 판단 가능



### for문

|                            기본형                            |                            실생활                            |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
| for (초기화 코드; 반복 조건식; 증감문)<br />{<br />반복할 코드<br />} | for (1부터; 30까지; 하나씩 증가)<br />{<br />팔굽혀펴기<br />} |

특정 코드를 **정해진 횟수**만큼 **반복**하는 구문



##### for문을 어떻게 읽어야 할까?

~~~c#
int[] ages = new int[3];

for (int i = 0; i < 3; ++i)
{
	ages[i] = int.Parse(Console.ReadLine());
}
~~~



### While반복문

|                            기본형                            |                            실생활                            |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
| while (조건식)<br />{<br />조건을 만족할 동안 반복할 코드<br />} | while (다이아몬드 티어가 될 때 까지)<br />{<br />랭크 게임을 한다<br />} |

- 특정한 조건을 만족하는 동안 코드를 반복
  - 반복할 횟수가 꼭 있지는 않음
  - 원한다면 무한반복(infinity loop)도 가능



##### while문을 어떻게 읽어야 할까?

~~~c#
int[] ages = new int[3];
int count = 0;

while (count < 3)
{
	ages[count] = int.Parse(Console.ReadLine());
  ++conut;
}
~~~





### do-while 반복문

- while문과 거의 유사
- do구문의 중괄호 코드 블럭을 **반드시 한번은 실행**

~~~c#
do
{
	//최소 한 번은 반드시 실행되는 코드
	// 란 번 실행 후엔느 조건식이 참일 때만 실행
} while (조건식);
~~~



##### do-while문을 어떻게 읽어야 할까?

~~~c#
int[] ages = new int[3];
int count = 0;

do
{
	ages[count] = int.Parse(Console.ReadLine());
  ++conut;
} while (count < 3);
~~~

1. 반복항 코드를 실행
2. 조건식이 참이면 돌아가 반복할 코드를 실행
3. 조건식이 참이 아니면 {}에서 나감





### for문 vs while문

- ##### for문이 더 좋을때

  - 반복문이 시작하는 시점에 범위가 정해져 있을 때
  - 배열의 모든 요소를 훑을 때

- ##### while문이 더 좋을 때

  - 반복문을 종료하는 시점이 반복문 실행 도중에 결정될 때



#### while문 vs do-while문

- ##### while문

  - 코드블럭이 한 번도 실행 안 될 수 있음

- ##### do-while문

  - 코드블럭이 무조건 한 번은 실행 됨

  ~~~c#
  // do-while문을 자주 쓰지는 않음
  // 대신 이렇게 자주 함
  
  while (true)
  {
  	if(조건식)
  	{
  		break;
  	}
  }
  ~~~

  



### 다차원배열(Multidimensional Array)

![스크린샷 2020-12-16 오전 10 01 55](https://user-images.githubusercontent.com/47776915/102291022-85079900-3f85-11eb-8dec-8319fb466719.png)

~~~c#
int[,] table = new int[2, 4];
<자료형>[,] <변수명> = new <자료형>[<행의 개수>, <열의 개수>];
~~~

- [,]은 2차원을 의미 → int[,]은 int형 2차원 배열을 위미
- `<행의 개수> * <열의 개수>개의 <자료형> 데이터를 담을 2D배열[,]을 만든다`



#### 2차원 배열 선언과 동시에 대입하기

![스크린샷 2020-12-16 오전 10 25 30](https://user-images.githubusercontent.com/47776915/102292593-d06f7680-3f88-11eb-9cbc-7e983684314b.png)

#### for문 속 for문 

~~~c#
int[,] table = new int[2, 3];
for (int i = 0; i < 2; ++i)
{
	for (int j = 0; j < 3; ++j)
	{
		table[i, j] = (i + 1) * (j + 1);
	}
}
~~~

- 2차원 배열을 순차적으로 접근하기 위해서는 for 문이 두개 필요
  - 행을 위한 for문
  - 열을 위한 for문

*반복문이 많아질수록 성능 기하급수적으로 떨어진다*

프로그램의 런타임 복잡도는 내포(중첩)된 반복문 개수에 비례

- 반복문이 한개일때: N개의 요소를 방문한다면 O(N) 
- 이중 반복문: N*N →O(N²)
- 삼중 반복문: N*N\*N →O(N³)

만약 N = 100이라면 반복문의 개수에 따라 100→10,000→1,000,000 증가

즉, O(N³)을 O(N)으로 만들수 있다면 10,000배 빨라질수 있다!

